using OculusSampleFramework;
using StarterAssets;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RightHand_PunchReady : MonoBehaviour
{
    [SerializeField] private GestureDetection_Demo GD;

    public GameObject targetGO;

    private string currentInterface;

    private Vector3 index_previousVelocity; // 이전 프레임의 속도
    private Vector3 index_currentVelocity; // 현재 프레임의 속도

    private Vector3 index_previousPosition; // 이전 프레임의 위치
    private Vector3 index_currentPosition; // 현재 프레임의 위치

    private Vector3 index_acceleration; // 가속도

    private float deltaTime; // 프레임 간의 시간 차이

    Animator anim;

    void Update()
    {
        currentInterface = GD.RecognizeRight().name;
        targetGO = GD.targetGO;

        if (currentInterface == "PunchReady")
        {
            if (targetGO != null && GD.targetName != "We")
            {
                // 구현
                if (!GD.thereAreBonesRight) return;

                anim = targetGO.GetComponent<Animator>();
                if (anim != null)
                    anim.SetBool("PunchReady", true);

                // 중지 시작 위치
                Vector3 middlePos = GD.skeletonRight.Bones[9].Transform.position;

                // 현재 프레임의 속도와 위치를 갱신
                index_currentVelocity = (middlePos - index_previousPosition) / Time.deltaTime;
                index_currentPosition = middlePos;

                // 프레임 간의 시간 차이
                deltaTime = Time.deltaTime;

                // 가속도 계산
                // 검지
                index_acceleration = (index_currentVelocity - index_previousVelocity) / deltaTime;

                // 가속도 값을 사용하여 원하는 작업 수행
                float speed = index_acceleration.magnitude * 0.01f;

                if (speed > 0.5f)
                {
                    if (GD.targetName == LeftHandTargets.HumanAvatar.ToString()
                        && targetGO.TryGetComponent(out StarterAssetsInputs input))
                    {
                        if (anim != null)
                        {
                            // punch anim
                            anim.SetTrigger("Punch");

                            GameObject punchTarget = FindAndLookAtEachOther();

                            if (punchTarget != null)
                            {
                                Animator punchTargetAnim = punchTarget.GetComponent<Animator>();
                                punchTargetAnim.SetTrigger("Stumble");
                            }
                        }
                    }
                }
                else
                {
                    if (anim != null)
                        anim.SetBool("Punch", false);
                }


                // 이전 프레임의 속도와 위치를 현재 값으로 갱신
                // 검지
                index_previousVelocity = index_currentVelocity;
                index_previousPosition = index_currentPosition;

            }
        }
        else
        {
            if (targetGO != null
                && GD.targetName == LeftHandTargets.HumanAvatar.ToString()
                && targetGO.TryGetComponent(out StarterAssetsInputs input))
            {
                anim = targetGO.GetComponent<Animator>();
                if (anim != null)
                    anim.SetBool("PunchReady", false);
            }
            targetGO = null;
        }
    }

    private GameObject FindAndLookAtEachOther()
    {
        Collider[] hits = Physics.OverlapSphere(targetGO.transform.position, 3, LayerMask.GetMask("InteractObj"));

        foreach (Collider hit in hits)
        {
            if (hit.CompareTag("Player") && hit.gameObject != targetGO)
            {
                // 타겟 오브젝트를 바라보게 합니다.
                Vector3 directionToTarget = hit.transform.position - transform.position;
                directionToTarget.y = 0; // Y축 회전은 고려하지 않음
                Quaternion lookRotation = Quaternion.LookRotation(directionToTarget);
                transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * 5f);

                // 자신을 타겟 오브젝트가 바라보게 합니다.
                Vector3 directionToSelf = transform.position - hit.transform.position;
                directionToSelf.y = 0; // Y축 회전은 고려하지 않음
                Quaternion lookRotationToSelf = Quaternion.LookRotation(directionToSelf);
                hit.transform.rotation = Quaternion.Slerp(hit.transform.rotation, lookRotationToSelf, Time.deltaTime * 5f);

                return hit.gameObject;
            }
            
        }

        return null;
    }
}
